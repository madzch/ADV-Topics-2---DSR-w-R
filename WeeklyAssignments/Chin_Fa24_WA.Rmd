---
title: "D2SC: Weekly Assignments"
author: "Madison Chin"
date: "`r Sys.Date()`"
output: html_notebook
---

# Initial Loading 
```{r}
#in order to load the tidyverse library you must run the following

library("tidyverse")
```

# Weekly Assignment 1

*In order to figure out which function loaded the tidyverse library, I searched the following into the Google Search Engine "load code chunk that loads tidyverse library". 

*I read the description given to me by first link "https://stackoverflow.com/questions/58289197/how-to-write-an-r-chunk-to-load-the-tidyverse"
, which after reading for a little bit, I found that someone had used the "library" function in order to load the library. 

*Then, I ran the above code chunk to figure out if the function would work for tidyverse. 

*The core tidyverse packages were correctly added, but there seems to be some "Conflicts" in the Terminal after I ran it. 

*But, after further research I found that these are not going to negatively affect any other code that I would write, but RStudio recommends using a "conflicted package" to turn these conflicts into errors.

```{r}
?tidyverse
#Below is the provided description after running #?tidyverse
```
The 'tidyverse' is a set of packages that work in harmony because they share common data representations and 'API' design. This package is designed to make it easy to install and load multiple 'tidyverse' packages in a single step. Learn more about the 'tidyverse' at https://www.tidyverse.org.

# Weekly Assignment 2

```{r}

read_csv("MFIndD_analogy.csv") #renamed 
#Here I am reading in the info from MFIndD_analogy.csv

file.rename("MFIndD_analogy.csv","Analogy_Dataset.csv")
#I was unable to find a direct function equivalent to
#the file.rename() function in  the tidyverse library

#When run, file.rename(...) returns true


```

The column that contains the unique identifier for each participate is titled "qualtrics_id" in the csv.

```{r}
analogy_data <- read_csv("Analogy_Dataset.csv")
#turning analogy data set into a usable and digestible variable. 
```


```{r}

glimpse(analogy_data)

```

2a. The above line of code results in a short "glimpse" revealing that the data set has 792 rows and 6 columns, in the first couple of lines of the output, as seen in the console when run.

```{r}
analogy_data%>%
group_by(qualtrics_id)%>%
summarise(N=n()) %>%
  distinct() %>%
  count() %>%
  head(n = 1)

  
```

2b. The above function proves that there are [99] distinct people in the trial. I could not just apply a simple summary of the amount of qualtrics_id's because there seemed to be some duplicates. This would mean that each ID is one person, so the number of unique id's would be equivalent to the total number of people in the entire experiment. 

```{r}
analogy_data%>%
group_by(qualtrics_id,trial_number)%>%
summarise(trial_number, count = n(), .groups = "drop_last")%>%
  count()
#I added the drop_last because I was getting an error"Adding missing grouping variables". 
#I have checked Stack Overflow for answers, and this one seems to work!
```



2c.Yes, everyone has data from the same number of trials. Each unique Id has  completed n trials, which for all are equal to [8] throughout the entire set. There are 99 rows which represents the number of people. So each person has data for 8 trials.

# Weekly Assignment 3 

```{r}
analogy_data%>%
 filter(response_type == "Rel") %>%              # Filter rows with response_type == "Rel"
  group_by(qualtrics_id) %>%                      # Group by qualtrics_id
  summarise(num_of_trials = n(), .groups = "drop") %>%  # Count the number of "Rel" responses per ID
  distinct(qualtrics_id, num_of_trials) -> num_of_trials

#I took inspiration from the code snippet from the previous assignment because it has those two columns mentioned in the instructions

#I am also checking to see if num_of_trials runs as expected separately from storing the info in "num_of_trials". Which it works as expected!

```
```{r}
num_of_trials
```

```{r}
num_of_trials%>%
  ggplot(aes(x = num_of_trials))+
           geom_histogram()+ 
 labs(y = "number of 'Rel' responses", 
      x = "amount of 'Rel' per person")

         


```
2. The variable previously known as "num_of_trials", now renamed to = amount of "Rel" per person, shows a disbursement of how many people responded with "Rel" a certain amount of times. It I also notice from the histogram that the majority of responses with "Rel" came from participants who responded to all of their trials with "Rel", which would not have been found out without this variable. 

```{r}
Analogy_Dataset.csv <- analogy_data #%>%
reshaped_data <- analogy_data %>%
  select(qualtrics_id, trial_number, response_type) %>%   # Select relevant columns
  filter(trial_number <= 8) %>%                          # Keep only the first 8 trials
  pivot_wider(names_from = trial_number,                 # Reshape from long to wide format
              values_from = response_type, 
              names_prefix = "trial_") %>%               # Rename trials to trial_1, trial_2, etc.
  select(qualtrics_id,trial_1, trial_2, trial_3, trial_4, trial_5, trial_6, trial_7, trial_8) # Ensure only 9 columns (ID + 8 trials) and put them in order! 
 
reshaped_data
```
```{r, eval=FALSE}
 #eval=FALSE (chunk header not showing on HTML) 
analogy_data%>%
group_by(qualtrics_id,response_type = "Rel")%>%
summarise(trial_number, .groups = "drop_last")%>%
  distinct(qualtrics_id,response_type)
#.groups = "drop_last")->

#The issue with this code is that response_type = "Rel" is not a valid way to filter the data within group_by(). Instead, this syntax is trying to create a new grouping variable that doesn't actually filter the data. As a result, the code does not return the expected results, and I ended up with a grouping that included unwanted response types.

#I also was having a hard time figuring out how to sort the trial numbers only using dplyr, but was able to get all of info on there by manually typing out trial_1 .... trial_8, but I had trouble optimizing this process to avoid possible human error. But all of the info is there!

```

