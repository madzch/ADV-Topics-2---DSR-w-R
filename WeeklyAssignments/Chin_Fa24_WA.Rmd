---
title: "D2SC: Weekly Assignments"
author: "Madison Chin"
date: "`r Sys.Date()`"
output: html_notebook
---

# Initial Loading 
```{r}
#in order to load the tidyverse library you must run the following

library(tidyverse)
```

# Weekly Assignment 1

*In order to figure out which function loaded the tidyverse library, I searched the following into the Google Search Engine "load code chunk that loads tidyverse library". 

*I read the description given to me by first link "https://stackoverflow.com/questions/58289197/how-to-write-an-r-chunk-to-load-the-tidyverse"
, which after reading for a little bit, I found that someone had used the "library" function in order to load the library. 

*Then, I ran the above code chunk to figure out if the function would work for tidyverse. 

*The core tidyverse packages were correctly added, but there seems to be some "Conflicts" in the Terminal after I ran it. 

*But, after further research I found that these are not going to negatively affect any other code that I would write, but RStudio recommends using a "conflicted package" to turn these conflicts into errors.

```{r}
?tidyverse
#Below is the provided description after running #?tidyverse
```
The 'tidyverse' is a set of packages that work in harmony because they share common data representations and 'API' design. This package is designed to make it easy to install and load multiple 'tidyverse' packages in a single step. Learn more about the 'tidyverse' at https://www.tidyverse.org.

# Weekly Assignment 2

```{r}

read_csv("MFIndD_analogy.csv") #renamed 
#Here I am reading in the info from MFIndD_analogy.csv

file.rename("MFIndD_analogy.csv","Analogy_Dataset.csv")
#I was unable to find a direct function equivalent to
#the file.rename() function in  the tidyverse library

#When run, file.rename(...) returns true


```

The column that contains the unique identifier for each participate is titled "qualtrics_id" in the csv.

```{r}
analogy_data <- read_csv("Analogy_Dataset.csv")
#turning analogy data set into a usable and digestible variable. 
```


```{r}

glimpse(analogy_data)

```

2a. The above line of code results in a short "glimpse" revealing that the data set has 792 rows and 6 columns, in the first couple of lines of the output, as seen in the console when run.

```{r}
analogy_data%>%
group_by(qualtrics_id)%>%
summarise(N=n()) %>%
  distinct() %>%
  count() %>%
  head(n = 1)

  
```

2b. The above function proves that there are [99] distinct people in the trial. I could not just apply a simple summary of the amount of qualtrics_id's because there seemed to be some duplicates. This would mean that each ID is one person, so the number of unique id's would be equivalent to the total number of people in the entire experiment. 

```{r}
analogy_data%>%
group_by(qualtrics_id,trial_number)%>%
summarise(trial_number, count = n(), .groups = "drop_last")%>%
  count()
#I added the drop_last because I was getting an error"Adding missing grouping variables". 
#I have checked Stack Overflow for answers, and this one seems to work!
```



2c.Yes, everyone has data from the same number of trials. Each unique Id has  completed n trials, which for all are equal to [8] throughout the entire set. There are 99 rows which represents the number of people. So each person has data for 8 trials.

# Weekly Assignment 3 

```{r}
num_of_trials <- analogy_data %>%
  group_by(qualtrics_id) %>%
  summarise(total_responses = n(), .groups = "drop") %>%  # Count total responses per ID
  left_join(                                                       # Join with the count of "Rel" responses
    analogy_data %>%
      filter(response_type == "Rel") %>%
      group_by(qualtrics_id) %>%
      summarise(num_of_trials = n(), .groups = "drop"), 
    by = "qualtrics_id"
  ) %>%
  mutate(num_of_trials = coalesce(num_of_trials, 0)) %>%  # Replace NA with 0 for those with no "Rel" responses
  distinct(qualtrics_id, num_of_trials)

#I reworked this using coalesce to take into account the 0's that should be showing up in the manipulated 
#dataset.

#I am also checking to see if num_of_trials runs as expected separately from storing the info in "num_of_trials". Which it works as expected!
```
```{r}
num_of_trials
```

```{r}
num_of_trials%>%
  ggplot(aes(x = num_of_trials))+
           geom_histogram()+ 
 labs(x = "number of 'Rel' responses", 
      y = "amount of people ")

         


```
2. The variable previously known as "num_of_trials", now renamed to = amount of people, shows a disbursement of how many people responded with "Rel" a certain amount of times. It I also notice from the histogram that the majority of responses came from participants who responded to all of their trials with "Obj", which would not have been found out without this variable. 

```{r}
Analogy_Dataset.csv <- analogy_data #%>%
reshaped_data <- analogy_data %>%
  select(qualtrics_id, trial_number, response_type) %>%   # Select relevant columns
  filter(trial_number <= 8) %>%                          # Keep only the first 8 trials
  pivot_wider(names_from = trial_number,                 # Reshape from long to wide format
              values_from = response_type, 
              names_prefix = "trial_") %>%               # Rename trials to trial_1, trial_2, etc.
  select(qualtrics_id,trial_1, trial_2, trial_3, trial_4, trial_5, trial_6, trial_7, trial_8) # Ensure only 9 columns (ID + 8 trials) and put them in order! 
 
reshaped_data
```
```{r, eval=FALSE}
 #eval=FALSE (chunk header not showing on HTML) 
analogy_data%>%
group_by(qualtrics_id,response_type = "Rel")%>%
summarise(trial_number, .groups = "drop_last")%>%
  distinct(qualtrics_id,response_type)


#The issue with this code is that response_type = "Rel" is not a valid way to filter the data within group_by(). Instead, this syntax is trying to create a new grouping variable that doesn't actually filter the data. As a result, the code does not return the expected results, and I ended up with a grouping that included unwanted response types.

#I also was having a hard time figuring out how to sort the trial numbers only using dplyr, but was able to get all of info on there by manually typing out trial_1 .... trial_8, but I had trouble optimizing this process to avoid possible human error. But all of the info is there!

```

# Weekly Assignment 4
```{r}
rationality_ques<- read_csv("MFIndD_REI.csv")
rationality_ques%>%
  head(6)
```

The column type of the "response" column is type <chr>, delineating a character data type ie ("A","b", aka "text"). The column type of the "scored response" column uses <dbl>,which are double (solely numeric) datatypes.This info was found directly underneath the column names. This is due to the fact that numbers AND letters can only exist in the same grouping (in this case the response column), if they are characters. This is true for the response column because not all of the data are numbers. For example, some of them say "Strongly Disagree" and others will have a number "4". In contrast, the scored response column is only numbers, so doubles as the datatype makes sense.



```{r}
dbl_response <-rationality_ques%>%
  mutate(response_dbl = case_when(
    response == "Strongly Disagree" ~ 1,
    response == "2" ~ 2,
    response == "3" ~ 3,
    response == "4" ~ 4,
    response == "Strongly Agree" ~ 5,
    TRUE ~ NA_real_ #to acknowledge and not replace any missing values
  ))
dbl_response

```
I wanted to have "TRUE ~ as.numeric(response)" instead of writing out response == 2,3,4, for efficiency. But, because this is a "base-r" function and not dplyr, I stuck to a redundant implementation. 
```{r}
#items that need to be scored are marked as "neg" if not then marked with "NA" 
new_score <- dbl_response%>%
  mutate(new_scored_response = if_else(
    rev_scoring == "neg", 6 - response_dbl,
    response_dbl,
    missing = response_dbl # this should account for all of the NA values
    ))

new_score
```
```{r}
new_score <- new_score %>%
mutate(is_equal = new_scored_response == scored_response)
# To check how many rows are not equal,filter those mismatches

mismatch_count <- new_score %>%
  filter(is_equal == FALSE) %>%
  count()

# View the count of mismatches
mismatch_count
  
```
n=0, So there are no mismatched values.
