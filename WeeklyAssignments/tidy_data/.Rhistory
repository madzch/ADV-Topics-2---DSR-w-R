mutate(new_scored_response = case_when(
rev_scoring = "neg" ~ 5 - response_dbl))
#items that need to be scored are marked as "neg" if not then marked with "NA"
dbl_response%>%
mutate(new_scored_response = case_when(
rev_scoring = "neg" ~ response_dbl + -6))
#items that need to be scored are marked as "neg" if not then marked with "NA"
dbl_response%>%
mutate(new_scored_response = case_match(
rev_scoring = "neg" ~ response_dbl + -6))
#items that need to be scored are marked as "neg" if not then marked with "NA"
dbl_response%>%
mutate(new_scored_response = case_when(
rev_scoring = "neg" ~ 6 - response_dbl,
TRUE = NA_real_))
#items that need to be scored are marked as "neg" if not then marked with "NA"
dbl_response%>%
mutate(new_scored_response = case_when(
rev_scoring == "neg" ~ 6 - response_dbl,
TRUE = NA_real_))
#items that need to be scored are marked as "neg" if not then marked with "NA"
dbl_response%>%
mutate(new_scored_response = case_when(
rev_scoring == "neg" ~ 6 - response_dbl,
TRUE == NA_real_))
#items that need to be scored are marked as "neg" if not then marked with "NA"
dbl_response%>%
mutate(new_scored_response = case_when(
rev_scoring == "neg" ~ 6 - response_dbl,
TRUE ~ NA_real_))
#items that need to be scored are marked as "neg" if not then marked with "NA"
dbl_response%>%
mutate(new_scored_response = case_when(
rev_scoring == "neg" ~ 6 - scored_response,
TRUE ~ NA_real_))
#items that need to be scored are marked as "neg" if not then marked with "NA"
dbl_response%>%
mutate(new_scored_response = case_when(
rev_scoring == "neg" ~ 6 - response_dbl,
TRUE ~ NA_real_))
#items that need to be scored are marked as "neg" if not then marked with "NA"
dbl_response%>%
mutate(new_scored_response = case_when(
rev_scoring == "neg" ~ 6 - response_dbl,
TRUE ~ NA_real_))
#items that need to be scored are marked as "neg" if not then marked with "NA"
dbl_response%>%
mutate(new_scored_response = case_when(
rev_scoring == "neg" ~ 6 - response_dbl,
rev_scoring == NA ~ response_dbl
TRUE ~ NA_real_))
#items that need to be scored are marked as "neg" if not then marked with "NA"
dbl_response%>%
mutate(new_scored_response = case_when(
rev_scoring == "neg" ~ 6 - response_dbl,
rev_scoring == "NA" ~ response_dbl
TRUE ~ NA_real_))
#items that need to be scored are marked as "neg" if not then marked with "NA"
dbl_response%>%
mutate(new_scored_response = case_when(
rev_scoring == "neg" ~ 6 - response_dbl,
rev_scoring = "NA" ~ response_dbl
TRUE ~ NA_real_))
#items that need to be scored are marked as "neg" if not then marked with "NA"
dbl_response%>%
mutate(new_scored_response = case_when(
rev_scoring == "neg" ~ 6 - response_dbl,
rev_scoring == NA ~ response_dbl
TRUE ~ NA_real_ ~ response_dbl))
#items that need to be scored are marked as "neg" if not then marked with "NA"
dbl_response%>%
mutate(new_scored_response = case_when(
rev_scoring == "neg" ~ 6 - response_dbl,
#rev_scoring == NA ~ response_dbl
TRUE ~ NA_real_ ~ response_dbl))
#items that need to be scored are marked as "neg" if not then marked with "NA"
dbl_response%>%
mutate(new_scored_response = if_else(
rev_scoring == "neg", 6 - response_dbl,response_dbl
)
#items that need to be scored are marked as "neg" if not then marked with "NA"
dbl_response%>%
mutate(new_scored_response = if_else(
rev_scoring == "neg", 6 - response_dbl,
response_dbl,
))
#items that need to be scored are marked as "neg" if not then marked with "NA"
dbl_response%>%
mutate(new_scored_response = if_else(
rev_scoring == "neg", 6 - response_dbl,
response_dbl,
missing = response_dbl
))
#items that need to be scored are marked as "neg" if not then marked with "NA"
new_score <- dbl_response%>%
mutate(new_scored_response = if_else(
rev_scoring == "neg", 6 - response_dbl,
response_dbl,
missing = response_dbl # this should account for all of the NA values
))
new_score
new_score %>%
mutate(is_equal = new_scored_response == scored_response)
# To check how many rows are not equal, you can filter those mismatches
mismatch_count <- analogy_data %>%
filter(is_equal == FALSE) %>%
count()
new_score %>%
mutate(is_equal = new_scored_response == scored_response)
# To check how many rows are not equal, you can filter those mismatches
mismatch_count <- new_score %>%
filter(is_equal == FALSE) %>%
count()
new_score <- new_score %>%
mutate(is_equal = new_scored_response == scored_response)
# To check how many rows are not equal, you can filter those mismatches
mismatch_count <- new_score %>%
filter(is_equal == FALSE) %>%
count()
# View the count of mismatches
mismatch_count
#in order to load the tidyverse library you must run the following
library(tidyverse)
getwd()
setwd)("C:/Users/mchin/OneDrive/Documents/GitHub/ADV-Topics-2---DSR-w-R/WeeklyAssignments/tidy_data")
setwd("C:/Users/mchin/OneDrive/Documents/GitHub/ADV-Topics-2---DSR-w-R/WeeklyAssignments/tidy_data")
read_csv("MFIndD_analogy.csv") #renamed
analogy_data <- read_csv("Analogy_Dataset.csv")
setwd("C:/Users/mchin/OneDrive/Documents/GitHub/ADV-Topics-2---DSR-w-R/WeeklyAssignments/tidy_data")
analogy_data <- read_csv("Analogy_Dataset.csv")
#turning analogy data set into a usable and digestible variable.
analogy_data <- read_csv("Analogy_Dataset.csv")
setwd(C:\Users\mchin\OneDrive\Documents\GitHub\ADV-Topics-2---DSR-w-R\WeeklyAssignments\tidy_data)
setwd("C:\Users\mchin\OneDrive\Documents\GitHub\ADV-Topics-2---DSR-w-R\WeeklyAssignments\tidy_data")
setwd("C:\Users\mchin\OneDrive\Documents\GitHub\ADV-Topics-2---DSR-w-R\WeeklyAssignments\tidy_data\Analogy_Dataset.csv")
setwd("C:\Users\mchin\OneDrive\Documents\GitHub\ADV-Topics-2---DSR-w-R\WeeklyAssignments\tidy_data\Analogy_Dataset.csv")
setwd("C:/Users/mchin/OneDrive/Documents/GitHub/ADV-Topics-2---DSR-w-R/WeeklyAssignments/tidy_data/Analogy_Dataset.csv")
setwd("C:/Users/mchin/OneDrive/Documents/GitHub/ADV-Topics-2---DSR-w-R/WeeklyAssignments/tidy_data")
analogy_data <- read_csv("Analogy_Dataset.csv")
read_csv("MFIndD_analogy.csv") #renamed
#in order to load the tidyverse library you must run the following
library(tidyverse)
read_csv("MFIndD_analogy.csv") #renamed
analogy_data <- read_csv("Analogy_Dataset.csv")
setwd("C:/Users/mchin/OneDrive/Documents/GitHub/ADV-Topics-2---DSR-w-R/WeeklyAssignments/tidy_data")
getwd()
#in order to load the tidyverse library you must run the following
library(tidyverse)
read_csv("MFIndD_analogy.csv") #renamed
analogy_data <- read_csv("Analogy_Dataset.csv")
glimpse(analogy_data)
#in order to load the tidyverse library you must run the following
library(tidyverse)
?tidyverse
#Below is the provided description after running #?tidyverse
read_csv("MFIndD_analogy.csv") #renamed
#in order to load the tidyverse library you must run the following
library(tidyverse)
?tidyverse
#Below is the provided description after running #?tidyverse
read_csv("MFIndD_analogy.csv") #renamed
analogy_data <- read_csv("Analogy_Dataset.csv")
glimpse(analogy_data)
analogy_data%>%
group_by(qualtrics_id)%>%
summarise(N=n()) %>%
distinct() %>%
count() %>%
head(n = 1)
analogy_data%>%
group_by(qualtrics_id,trial_number)%>%
summarise(trial_number, count = n(), .groups = "drop_last")%>%
count()
#I added the drop_last because I was getting an error"Adding missing grouping variables".
#I have checked Stack Overflow for answers, and this one seems to work!
num_of_trials <- analogy_data %>%
group_by(qualtrics_id) %>%
summarise(total_responses = n(), .groups = "drop") %>%  # Count total responses per ID
left_join(                                                       # Join with the count of "Rel" responses
analogy_data %>%
filter(response_type == "Rel") %>%
group_by(qualtrics_id) %>%
summarise(num_of_trials = n(), .groups = "drop"),
by = "qualtrics_id"
) %>%
mutate(num_of_trials = coalesce(num_of_trials, 0)) %>%  # Replace NA with 0 for those with no "Rel" responses
distinct(qualtrics_id, num_of_trials)
#I reworked this using coalesce to take into account the 0's that should be showing up in the manipulated
#dataset.
#I am also checking to see if num_of_trials runs as expected separately from storing the info in "num_of_trials". Which it works as expected!
num_of_trials%>%
ggplot(aes(x = num_of_trials))+
geom_histogram()+
labs(x = "number of 'Rel' responses",
y = "amount of people ")
rationality_ques<- read_csv("MFIndD_REI.csv")
dbl_response <-rationality_ques%>%
mutate(response_dbl = case_when(
response == "Strongly Disagree" ~ 1,
response == "2" ~ 2,
response == "3" ~ 3,
response == "4" ~ 4,
response == "Strongly Agree" ~ 5,
TRUE ~ NA_real_ #to acknowledge and not replace any missing values
))
dbl_response
#items that need to be scored are marked as "neg" if not then marked with "NA"
new_score <- dbl_response%>%
mutate(new_scored_response = if_else(
rev_scoring == "neg", 6 - response_dbl,
response_dbl,
missing = response_dbl # this should account for all of the NA values
))
new_score
new_score <- new_score %>%
mutate(is_equal = new_scored_response == scored_response)
# To check how many rows are not equal,filter those mismatches
mismatch_count <- new_score %>%
filter(is_equal == FALSE) %>%
count()
# View the count of mismatches
mismatch_count
getcd()
getwd()
#in order to load the tidyverse library you must run the following
library(tidyverse)
setwd("C:/Users/mchin/OneDrive/Documents/GitHub/ADV-Topics-2---DSR-w-R/WeeklyAssignments/tidy_data")
knitr root.dir
analogy_data <- read_csv("Analogy_Dataset.csv")
#in order to load the tidyverse library you must run the following
library(tidyverse)
read_csv("MFIndD_analogy.csv") #renamed
analogy_data <- read_csv("Analogy_Dataset.csv")
knitr::opts_knit$set(root.dir = "~/GitHub/ADV-Topics-2---DSR-w-R/WeeklyAssignments/tidy_data")
#had to be added for working dir issues, now fixed
rei_summary <- new_score %>%
filter(sub_type %in% c("EA", "EE", "RE", "RA")) %>% # Keep only relevant sub_types
group_by(qualtrics_id, sub_type) %>%
summarise(score = sum(new_scored_response), #na.rm = TRUE),
.groups = 'drop')
rei_summary <- new_score %>%
filter(sub_type %in% c("EA", "EE", "RE", "RA")) %>% # Keep only relevant sub_types
group_by(qualtrics_id, sub_type) %>%
summarise(score = sum(new_scored_response, na.rm = FALSE), .groups = 'drop')
rei_summary <- new_score %>%
filter(sub_type %in% c("EA", "EE", "RE", "RA")) %>% # Keep only relevant sub_types
group_by(qualtrics_id, sub_type) %>%
summarise(score = sum(new_scored_response, na.rm = FALSE), .groups = 'drop')
library(tidyverse)
rei_summary <- new_score %>%
filter(sub_type %in% c("EA", "EE", "RE", "RA")) %>% # Keep only relevant sub_types
group_by(qualtrics_id, sub_type) %>%
summarise(score = sum(new_scored_response, na.rm = FALSE), .groups = 'drop')
# Check the summary to confirm it has the right number of rows
#print(complete_rei_summary)
rei_summary
#Question 1b
rei_summary <- new_score %>%
filter(sub_type %in% c("EA", "EE", "RE", "RA")) %>% # Keep only relevant sub_types
group_by(qualtrics_id, sub_type) %>%
summarise(score = sum(new_scored_response, na.rm = FALSE), .groups = 'drop')
#The above code chunk is similar to this one here.The only difference is that the na.rm status is set to default where na.rm = false. There are indeed NA values, and I will summarize them in the following code chunk.
rei_summary
#Question 1b (part two)
na_filter <- rei_summary
filter(is.na (na_filter))
#Question 1b (part two)
na_filter <- rei_summary
filtered <-is.na(na_filter)
#Question 1b (part two)
na_filter <- rei_summary
filtered <-is.na(na_filter)
filtered
#Question 1b (part two)
na_filter <- rei_summary
filtered <- is.na(filter(na_filter))
filtered
#Question 1b (part two)
na_filter <- rei_summary
filtered <- is.na(filter(na_filter)) = TRUE
#Question 1b (part two)
na_filter <- rei_summary
filtered <- is.na(filter(na_filter)= TRUE )
#Question 1b (part two)
na_filter <- rei_summary
filtered <- is.na(filter(na_filter)== TRUE )
filtered
#Question 1b (part two)
na_filter <- rei_summary
filtered <- is.na(filter(na_filter)== TRUE )
summarize (filtered == TRUE)
#Question 1b (part two)
na_filter <- rei_summary
filtered <- is.na(filter(na_filter)== TRUE )
summarize (filtered)
#Question 1b (part two)
na_filter <- rei_summary
filtered <- is.na(filter(na_filter)== TRUE )
summarize (filtered)
#Question 1b (part two)
na_filter <- rei_summary
filtered <- filter(if_any(na_filter,is.na)
summarize (filtered)
#Question 1b (part two)
na_filter <- rei_summary
filtered <- filter(if_any(na_filter,is.na)
#Question 1b (part two)
na_filter <- rei_summary
filtered <- filter(if_any(na_filter,is.na))
#Question 1b (part two)
na_filter <- rei_summary
filtered <- groupby( qualtrics_id,
filter(if_any(na_filter,is.na))
)
#Question 1b (part two)
na_filter <- rei_summary
filtered <- group_by( qualtrics_id,
filter(if_any(na_filter,is.na))
)
knitr::opts_knit$set(root.dir = "~/GitHub/ADV-Topics-2---DSR-w-R/WeeklyAssignments/tidy_data")
#had to be added for working dir issues, now fixed
#in order to load the tidyverse library you must run the following
library(tidyverse)
?tidyverse
#Below is the provided description after running #?tidyverse
read_csv("MFIndD_analogy.csv") #renamed
#Question 1b (part two)
na_filter <- rei_summary
filtered <- group_by(
filter(if_any(na_filter,is.na))
)
#Question 1b (part two)
na_filter <- rei_summary%>%
filtered <- group_by(
filter(if_any(na_filter,is.na))
)
#Question 1b (part two)
na_filter <- rei_summary%>%
filtered <- group_by(qualtrics_id
filter(if_any(na_filter,is.na))
#Question 1b (part two)
na_filter <- rei_summary%>%
group_by(qualtrics_id,
filter(if_any(na_filter,is.na)))
#Question 1b (part two)
na_filter <- rei_summary%>%
group_by(qualtrics_id,
filter(if_any(na_filter,is.na(score))))
#Question 1b (part two)
rei_summary%>%
group_by(qualtrics_id,
filter(if_any(na_filter,is.na(score))))
#Question 1b (part two)
rei_summary%>%
filter(if_any(na_filter,is.na(score))))
#Question 1b (part two)
rei_summary%>%
filter(if_any(na_filter,is.na(score)))
# Question 1a
rei_summary <- new_score %>%
filter(sub_type %in% c("EA", "EE", "RE", "RA")) %>% # Keep only relevant sub_types
group_by(qualtrics_id, sub_type) %>%
summarise(score = sum(new_scored_response, na.rm = TRUE), .groups = 'drop')
# Check the summary to confirm it has the right number of rows
rei_summary
#Question 1b (part 1)
rei_summary <- new_score %>%
filter(sub_type %in% c("EA", "EE", "RE", "RA")) %>% # Keep only relevant sub_types
group_by(qualtrics_id, sub_type) %>%
summarise(score = sum(new_scored_response, na.rm = FALSE), .groups = 'drop')
#The above code chunk is similar to this one here.The only difference is that the na.rm status is set to default where na.rm = false. There are indeed NA values scattered throughout, and I will summarize them in the following code chunk.
rei_summary
#Question 1b (part two)
rei_summary%>%
filter(if_any(na_filter,is.na(score)))
#Question 1b (part two)
rei_summary%>%
filter(is.na(score))
library(tidyverse)
#items that need to be scored are marked as "neg" if not then marked with "NA"
new_score <- dbl_response%>%
mutate(new_scored_response = if_else(
rev_scoring == "neg", 6 - response_dbl,
response_dbl,
missing = response_dbl # this should account for all of the NA values
))
new_score
new_score <- new_score %>%
mutate(is_equal = new_scored_response == scored_response)
# To check how many rows are not equal,filter those mismatches
mismatch_count <- new_score %>%
filter(is_equal == FALSE) %>%
count()
# View the count of mismatches
mismatch_count
# Question 1a
rei_summary <- new_score %>%
filter(sub_type %in% c("EA", "EE", "RE", "RA")) %>% # Keep only relevant sub_types
group_by(qualtrics_id, sub_type) %>%
summarise(score = sum(new_scored_response, na.rm = TRUE), .groups = 'drop')
# Check the summary to confirm it has the right number of rows
rei_summary
#Question 1b (part 1)
rei_summary <- new_score %>%
filter(sub_type %in% c("EA", "EE", "RE", "RA")) %>% # Keep only relevant sub_types
group_by(qualtrics_id, sub_type) %>%
summarise(score = sum(new_scored_response, na.rm = FALSE), .groups = 'drop')
#The above code chunk is similar to this one here.The only difference is that the na.rm status is set to default where na.rm = false. There are indeed NA values scattered throughout, and I will summarize them in the following code chunk.
rei_summary
#Question 1b (part two)
rei_summary%>%
filter(is.na(score))
#This represents all people who have no "score" recorded for the respective trial(from the summary).
# 1c Here I'll switch the na.rm "condition" back to true as I had it in my original (first code snippet) which I will replicate down below. This will assure that the scores are calculated and represented properly.
rei_summary <- new_score %>%
filter(sub_type %in% c("EA", "EE", "RE", "RA")) %>% # Keep only relevant sub_types
group_by(qualtrics_id, sub_type) %>%
summarise(score = sum(new_scored_response, na.rm = TRUE), .groups = 'drop')
# 1c Here I'll switch the na.rm "condition" back to true as I had it in my original (first code snippet) which I will replicate down below. This will assure that the scores are calculated and represented properly.
rei_summary <- new_score %>%
filter(sub_type %in% c("EA", "EE", "RE", "RA")) %>% # Keep only relevant sub_types
group_by(qualtrics_id, sub_type) %>%
summarise(score = sum(new_scored_response, na.rm = TRUE), .groups = 'drop')
rei_summary
?join_by
# 2 Combining the summarized datasets from analogy and rei(that we just finished):
left_join(rei_summary, num_of_trials, by = qualtrics_id)
# 2 Combining the summarized datasets from analogy and rei(that we just finished):
left_join(rei_summary, num_of_trials, by = NULL)
# 2 Combining the summarized datasets from analogy and rei(that we just finished):
left_join(rei_summary,reshaped_data, by = NULL)
# 2 Combining the summarized datasets from analogy and rei(that we just finished):
left_join(rei_summary,reshaped_data, by = NULL)
library(tidyverse)
Analogy_Dataset.csv <- analogy_data #%>%
reshaped_data <- analogy_data %>%
select(qualtrics_id, trial_number, response_type) %>%   # Select relevant columns
filter(trial_number <= 8) %>%                          # Keep only the first 8 trials
pivot_wider(names_from = trial_number,                 # Reshape from long to wide format
values_from = response_type,
names_prefix = "trial_") %>%               # Rename trials to trial_1, trial_2, etc.
select(qualtrics_id,trial_1, trial_2, trial_3, trial_4, trial_5, trial_6, trial_7, trial_8) # Ensure only 9 columns (ID + 8 trials) and put them in order!
reshaped_data
# 1c Here I'll switch the na.rm "condition" back to true as I had it in my original (first code snippet) which I will replicate down below. This will assure that the scores are calculated and represented properly.
rei_summary <- new_score %>%
filter(sub_type %in% c("EA", "EE", "RE", "RA")) %>% # Keep only relevant sub_types
group_by(qualtrics_id, sub_type) %>%
summarise(score = sum(new_scored_response, na.rm = TRUE), .groups = 'drop')
rei_summary
# 2 Combining the summarized datasets from analogy and rei(that we just finished):
left_join(rei_summary,reshaped_data, by = NULL)
# 2 Combining the summarized datasets from analogy and rei(that we just finished):
left_join(rei_summary,num_of_trials, by = NULL)
# 2 Combining the summarized datasets from analogy and rei(that we just finished):
left_join(rei_summary,num_of_trials, by = NULL) <- combined_data
# 2 Combining the summarized datasets from analogy and rei(that we just finished):
combined_data <- left_join(rei_summary,num_of_trials, by = NULL) <- combined_data
# 2 Combining the summarized datasets from analogy and rei(that we just finished):
left_join(rei_summary,num_of_trials, by = NULL) <- combined_data
# 2 Combining the summarized datasets from analogy and rei(that we just finished):
left_join(rei_summary,num_of_trials, by = NULL) %>%
combined_data
# 2 Combining the summarized datasets from analogy and rei(that we just finished):
left_join(rei_summary,num_of_trials, by = NULL) <-
combined_data
# 2 Combining the summarized datasets from analogy and rei(that we just finished):
joined_data <- left_join(rei_summary,num_of_trials, by = NULL)
#num_trials is the number of trials that the corresponding person (qualtrics_id) responded with "Rel".
# 2 Combining the summarized datasets from analogy and rei(that we just finished):
joined_data <- left_join(rei_summary,num_of_trials, by = qualtrics_id)
# 2 Combining the summarized datasets from analogy and rei(that we just finished):
joined_data <- left_join(rei_summary,num_of_trials, by = qualtrics)
# 2 Combining the summarized datasets from analogy and rei(that we just finished):
joined_data <- left_join(rei_summary,num_of_trials, by = qualtrics_id)
# 2 Combining the summarized datasets from analogy and rei(that we just finished):
joined_data <- left_join(rei_summary,num_of_trials, by = NULL)
#num_trials is the number of trials that the corresponding person (qualtrics_id) responded with "Rel".
# 2 Combining the summarized datasets from analogy and rei(that we just finished):
joined_data <- left_join(rei_summary,num_of_trials, by = ('qualtrics_id'))
#num_trials is the number of trials that the corresponding person (qualtrics_id) responded with "Rel".
# 2 Combining the summarized datasets from analogy and rei(that we just finished):
joined_data <- left_join(rei_summary,num_of_trials, by = ('qualtrics_id'))
#num_trials is the number of trials that the corresponding person (qualtrics_id) responded with "Rel".
joined_data
# Scatterplot for relationship between REI score and newscore
ggplot(joined_data, aes(x = score, y = num_of_trials, color = sub_type)) +
geom_point() +
geom_smooth(method = "lm") +
labs(title = "REI Scores by Subtype",
x = "Sub Type", y = "Total Score") +
theme_minimal()
# Scatterplot for relationship between REI score and newscore
ggplot(joined_data, aes(x = score, y = num_of_trials, color = sub_type)) +
geom_point() +
geom_smooth(method = "lm") +
labs(title = "REI Scores by Subtype",
x = "Sub Type Scores", y = " Number of Rel responses") +
theme_minimal()
# Scatterplot for relationship between REI score and newscore
ggplot(joined_data, aes(x = num_of_trials, y = score, color = sub_type)) +
geom_point() +
geom_smooth(method = "lm") +
labs(title = "REI Scores by Subtype",
y = "Sub Type Scores", x = " Number of Rel responses") +
theme_minimal()
# Scatterplot for relationship between REI score and newscore
ggplot(joined_data, aes(x = num_of_trials, y = score, color = sub_type)) +
geom_point() +
geom_smooth(method = "lm") +
labs(title = "REI Scores by Subtype",
y = " Sum of Sub Type Scores", x = " Number of Rel responses") +
theme_minimal()
